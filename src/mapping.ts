//@ts-ignore
import { BigInt, Bytes, Event } from "@hyperoracle/zkgraph-lib";
import {
  Configs
} from "./static/tokens";

import {
  updateConfigWithEvent
} from "./modules/configUpdater";
import { updateCloseFactor, updateCollateralFactor } from "./modules/factorUpdater";
import { calculateTotalValue, calculateTotalPrincipal } from "./modules/assetAggregator";

const configs = new Configs();

/**
 * The idea of Compound Liquidator Automation is to monitor three types of events, 
 * namely NewCloseFactor, NewCollateralFactor, and Sync, 
 * in order to calculate whether the current user can be liquidated.
 *
 * @param {Event[]} events - The list of Event objects to handle.
 * @return {Bytes} The generated Bytes object.
 */
export function handleEvents(events: Event[]): Bytes {
  // step1: If there is a NewCloseFactor or NewCollateralFactor event 
  // override the hardcoded Factor.
  let closeFactor = updateCloseFactor(events);
  let collateralFactor = updateCollateralFactor(events);
  
  // step2: Update Balance and Principal by processing Mint Redeem Borrow Repay
  // Mint make balance +; Redeem make balance -
  // Borrow make principal +; Repay make Principal -
  updateConfigWithEvent(configs, events);

  // step3: calculate totalValue and totalPrincipal
  // totalValue += balance * price * COLLATERAL_FACTOR
  const totalValue = calculateTotalValue(configs, events, collateralFactor);
  const totalPrincipal = calculateTotalPrincipal(configs, events);

  // step4: return totalValue <= totalPrincipal
  const resultInt = totalValue <= totalPrincipal ? 1 : 0;
  return Bytes.fromI32(resultInt);
}
